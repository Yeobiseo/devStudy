## Design Pattern
디자인 패턴(Design Pattern)은 소프트웨어 설계에서 자주 발생하는 문제를 해결하기 위한 일반적이고 재사용 가능한 솔루션을 제공합니다.
디자인 패턴은 특정 문제를 해결하기 위한 일련의 지침과 규칙을 제공하며, 코드 재사용성과 유지보수성을 높이는 데 기여합니다.
디자인 패턴은 크게 세 가지 유형으로 분류할 수 있습니다. 생성 패턴(Creational Patterns), 구조 패턴(Structural Patterns),
그리고 행동 패턴(Behavioral Patterns). 각 유형의 대표적인 패턴은 다음과 같습니다.
<br>
<br>

### 생성 패턴 (Creational Patterns)
> **1. 싱글턴 패턴 (Singleton Pattern)**
> - 특정 클래스의 인스턴스가 하나만 존재하도록 보장하는 패턴입니다.
> - 주로 전역 상태를 관리할 때 사용됩니다.
<br>
  
> **2. 팩토리 메서드 패턴 (Factory Method Pattern)**
> - 객체 생성 코드를 캡슐화하여, 서브클래스가 어떤 객체를 생성할지를 결정하게 하는 패턴입니다.
> - 객체 생성의 책임을 서브클래스에 위임합니다.
<br>

> **3. 추상 팩토리 패턴 (Abstract Factory Pattern)**
> - 관련된 객체들을 생성하는 인터페이스를 제공하여 구체적인 클래스들을 지정하지 않고 객체를 생성할 수 있게 하는 패턴입니다.
> - 서로 관련 있는 객체들을 묶어서 생성합니다.
<br>

> **4. 빌더 패턴 (Builder Pattern)**
> - 복잡한 객체를 단계별로 생성할 수 있게 하는 패턴입니다.
> - 객체 생성 과정을 분리하여, 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있습니다.
<br>

> **5. 프로토타입 패턴 (Prototype Pattern)**
> - 새로운 객체를 생성하는 대신 기존 객체를 복사하여 새로운 객체를 생성하는 패턴입니다.
> - 객체의 초기화 비용을 줄일 수 있습니다.
<br>

### 구조 패턴 (Structural Patterns)
> **1. 어댑터 패턴 (Adapter Pattern)**
> - 호환되지 않는 인터페이스를 가진 클래스들을 함께 동작할 수 있도록 어댑터를 사용하여 변환해주는 패턴입니다.
> - 기존 클래스를 변경하지 않고 재사용할 수 있습니다.
<br>

> **2. 브리지 패턴 (Bridge Pattern)**
> - 구현부에서 추상층을 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴입니다.
> - 기능의 계층과 구현의 계층을 분리합니다.
<br>

> **3. 컴포지트 패턴 (Composite Pattern)**
> - 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴입니다.
> - 개벽 객체와 복잡 객체를 동일하게 다룰 수 있습니다.
<br>

> **4. 데코레이터 패턴 (Decorator Pattern)**
> - 객체에 동적으로 새로운 기능을 추가할 수 있게 하는 패턴입니다.
> -  서브클래스를 만들지 않고도 객체의 기능을 확장할 수 있습니다.
<br>

> **5. 퍼사드 패턴 (Facade Pattern)**
> - 복잡한 서브시스템에 대한 간단한 인터페이스를 제공하여 사용자가 서브시스템을 쉽게 사용할 수 있게 하는 패턴입니다.
<br>

> **6. 플라이웨이트 패턴 (Flyweight Pattern)**
> - 많은 수의 객체를 효율적으로 지원하기 위해 객체를 공유하여 메모리를 절약하는 패턴입니다.
<br>

> **7. 프록시 패턴 (Proxy Pattern)**
> - 실제 객체에 대한 접근을 제어하는 대리 객체를 제공하는 패턴입니다.
> - 접근 제어, 지연 초기화, 로깅 등에 사용됩니다.
<br>

### 행동 패턴 (Behavioral Patterns)
> **1. 책임 연쇄 패턴 (Chain of Responsivility Pattern)**
> - 요청을 처리할 수 있는 기회를 여러 객체에게 제공하여, 객체들이 서로 연결된 형태로 요청을 전달하는 패턴입니다.
<br>

> **2. 커맨드 패턴 (Command Pattern)**
> - 요청을 캡슐화하여 호출자와 수신자를 분리하는 패턴입니다.
> - 요청을 객체로 표현하여 다양한 요청, 큐잉, 로깅 등을 지원합니다.
<br>

> **3. 인터프리터 패턴 (Interpreter Pattern)**
> - 언어의 문법을 정의하고 해석하는 패턴입니다.
> - 간단한 언어의 구문을 해석하고 실행하는 데 사용됩니다.
<br>

> **4. 이터레이터 패턴 (Iterator Pattern)**
> - 컬렉션의 요소들을 순차적으로 접근할 수 있도록 하는 패턴입니다.
> - 내부 구현을 노출하지 않고도 컬렉션을 순회할 수 있습니다.
<br>

> **5. 중재자 패턴 (Mediator Pattern)**
> - 객체들이 직접 통신하지 않고 중재자를 통해 통신하게 하여 객체 간의 결합도를 줄이는 패턴입니다.
<br>

> **6. 메멘토 패턴 (Memento Pattern)**
> - 객체의 상태를 캡슐화하여 저장하고 복원할 수 있게 하는 패턴입니다.
> - 객체의 상태를 저장하고 나중에 복원할 수 있습니다.
<br>

> **7. 옵서버 패턴 (Observer Pattern)**
> - 객체의 상태 변화에 따라 다른 객체들이 통지받아 자동으로 갱신되도록 하는 패턴입니다.
> - 일대다 관계를 정의합니다.
<br>

> **8. 상태 패턴 (state Pattern)**
> - 객체의 상태에 따라 행동을 다르게 처리하는 패턴입니다.
> - 상태를 객체로 캡슐화하여 상태 변경을 처리합니다.
<br>

> **9. 전략 패턴 (Strategy Pattern)**
> - 알고리즘을 캡슐화하여 상호 교환 가능하게 만드는 패턴입니다.
> - 런타임에 알고리즘을 선택할 수 있게 합니다.
<br>

> **10. 템플릿 메서드 패턴 (Template Method Pattern)**
> - 상위 클래스에서 기본 구조를 정의하고, 하위 클래스에서 구체적인 기능을 구현하도록 하는 패턴입니다.
<br>

> **11. 방문자 패턴 (Visitor Pattern)**
> - 객체 구조를 변경하지 않고도 새로운 기능을 추가할 수 있게 하는 패턴입니다.
> - 객체 구조를 방문하여 연산을 수행합니다.
